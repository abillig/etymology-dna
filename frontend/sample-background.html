<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organic Leaf Accumulation Background</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1a2f1a 0%, #2d5a2d 30%, #1f3a1f 100%);
            overflow: hidden;
            min-height: 100vh;
            position: relative;
        }
        
        /* Organic background elements */
        .organic-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        
        .tree-branch {
            position: absolute;
            width: 2px;
            background: linear-gradient(to bottom, 
                rgba(139, 195, 74, 0.3) 0%,
                rgba(76, 175, 80, 0.2) 50%,
                transparent 100%
            );
            animation: grow 8s ease-in-out infinite alternate;
        }
        
        .branch-1 {
            left: 10%;
            top: 20%;
            height: 300px;
            transform: rotate(15deg);
            animation-delay: 0s;
        }
        
        .branch-2 {
            right: 15%;
            top: 30%;
            height: 250px;
            transform: rotate(-20deg);
            animation-delay: 2s;
        }
        
        .branch-3 {
            left: 60%;
            bottom: 20%;
            height: 200px;
            transform: rotate(45deg);
            animation-delay: 4s;
        }
        
        @keyframes grow {
            0% { height: 50px; opacity: 0.1; }
            100% { height: 100%; opacity: 0.3; }
        }
        
        .floating-leaf {
            position: absolute;
            width: 18px;
            height: 18px;
            background: radial-gradient(ellipse at center, #8bc34a, #4caf50);
            border-radius: 0 100% 0 100%;
            transition: all 0.3s ease;
            z-index: 1;
        }
        
        .floating-leaf.rising {
            animation: float-up 8s ease-out forwards;
        }
        
        .floating-leaf.settled {
            animation: none;
            position: fixed;
            transition: all 0.5s ease;
        }
        
        .floating-leaf.settled:hover {
            transform: scale(1.2) rotate(10deg);
            filter: brightness(1.2);
        }
        
        @keyframes float-up {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 0;
                animation-timing-function: ease-out;
            }
            10% { 
                opacity: 1;
                animation-timing-function: ease-out;
            }
            70% {
                animation-timing-function: ease-out;
            }
            85% {
                animation-timing-function: ease-in;
            }
            100% {
                transform: translateY(-100vh) rotate(360deg);
                opacity: 1;
                animation-timing-function: ease-in;
            }
        }
        

    </style>
</head>
<body>
    <div class="organic-bg">
        <div class="tree-branch branch-1"></div>
        <div class="tree-branch branch-2"></div>
        <div class="tree-branch branch-3"></div>
    </div>
    

    
    <script>
        class LeafSystem {
            constructor() {
                this.leaves = [];
                this.settledLeaves = [];
                this.isRunning = true;
                this.leafCount = 0;
                this.leafSpeed = 5000; // ms between new leaves
                this.counter = document.getElementById('counter');
                this.speedIndex = 0;
                this.speeds = [
                    { name: 'Slow', interval: 5000 }
                ];
                this.init();
            }
            
            init() {
                this.startLeafGeneration();
            }
            
            createLeaf() {
                if (!this.isRunning) return;
                
                const leaf = document.createElement('div');
                leaf.className = 'floating-leaf rising';
                
                // Random starting position at bottom
                const startX = Math.random() * (window.innerWidth - 20);
                leaf.style.left = startX + 'px';
                leaf.style.bottom = '-20px';
                
                // Random slight variations
                const hue = 80 + Math.random() * 40; // Green variations
                const saturation = 60 + Math.random() * 40;
                const lightness = 40 + Math.random() * 20;
                leaf.style.background = `radial-gradient(ellipse at center, 
                    hsl(${hue}, ${saturation}%, ${lightness + 10}%), 
                    hsl(${hue}, ${saturation}%, ${lightness}%))`;
                
                // Slightly random size
                const size = 16 + Math.random() * 6;
                leaf.style.width = size + 'px';
                leaf.style.height = size + 'px';
                
                document.body.appendChild(leaf);
                this.leaves.push(leaf);
                
                // Start collision detection
                this.startCollisionDetection(leaf);
                
                this.leafCount++;
            }
            
            startCollisionDetection(leaf) {
                const checkCollision = () => {
                    if (!leaf.parentNode || leaf.classList.contains('settled')) return;
                    
                    const leafRect = leaf.getBoundingClientRect();
                    const leafSize = 20; // approximate leaf size
                    
                    // Check collision with settled leaves - only care about leaves above this one
                    for (let settledLeaf of this.settledLeaves) {
                        const settledRect = settledLeaf.getBoundingClientRect();
                        
                        // Check if this rising leaf is hitting a settled leaf from below
                        // (horizontal overlap AND the rising leaf is just below the settled leaf)
                        if (leafRect.left < settledRect.right &&
                            leafRect.right > settledRect.left &&
                            leafRect.top <= settledRect.bottom + 2 && // Small buffer
                            leafRect.top >= settledRect.bottom - leafSize) {
                            
                            // Position this leaf just below the blocking leaf
                            this.settleLeafBelow(leaf, settledRect.bottom);
                            return;
                        }
                    }
                    
                    // Check if reached top of screen
                    if (leafRect.top <= 0) {
                        this.settleLeafAtTop(leaf);
                        return;
                    }
                    
                    // Continue checking at next frame
                    requestAnimationFrame(checkCollision);
                };
                
                // Start checking immediately
                requestAnimationFrame(checkCollision);
            }
            
            settleLeafBelow(leaf, blockingY) {
                if (leaf.classList.contains('settled')) return;
                
                leaf.classList.remove('rising');
                leaf.classList.add('settled');
                
                // Position leaf just below the blocking leaf
                const leafRect = leaf.getBoundingClientRect();
                leaf.style.position = 'fixed';
                leaf.style.top = blockingY + 'px';
                leaf.style.left = leafRect.left + 'px';
                leaf.style.bottom = 'auto';
                leaf.style.animation = 'none';
                leaf.style.transform = `rotate(${Math.random() * 20 - 10}deg)`;
                
                // Remove from rising leaves, add to settled
                const index = this.leaves.indexOf(leaf);
                if (index > -1) {
                    this.leaves.splice(index, 1);
                }
                this.settledLeaves.push(leaf);
            }
            
            settleLeafAtTop(leaf) {
                if (leaf.classList.contains('settled')) return;
                
                leaf.classList.remove('rising');
                leaf.classList.add('settled');
                
                // Position at top of screen
                const leafRect = leaf.getBoundingClientRect();
                leaf.style.position = 'fixed';
                leaf.style.top = '0px';
                leaf.style.left = leafRect.left + 'px';
                leaf.style.bottom = 'auto';
                leaf.style.animation = 'none';
                leaf.style.transform = `rotate(${Math.random() * 20 - 10}deg)`;
                
                // Remove from rising leaves, add to settled
                const index = this.leaves.indexOf(leaf);
                if (index > -1) {
                    this.leaves.splice(index, 1);
                }
                this.settledLeaves.push(leaf);
            }
            
            
            // Legacy method - keeping for compatibility
            settleLeaf(leaf) {
                this.settleLeafAtTop(leaf);
            }
            
            findSettlePosition() {
                const leafSize = 20;
                const margin = 2;
                const effectiveSize = leafSize + margin;
                
                // Calculate grid dimensions
                const cols = Math.floor(window.innerWidth / effectiveSize);
                const maxRows = Math.floor(100 / effectiveSize); // Top 100px
                
                // Try to find an empty spot, starting from top
                for (let row = 0; row < maxRows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const x = col * effectiveSize + margin;
                        const y = row * effectiveSize + margin;
                        
                        // Check if position is occupied
                        const occupied = this.settledLeaves.some(settledLeaf => {
                            const leafRect = settledLeaf.getBoundingClientRect();
                            const distance = Math.sqrt(
                                Math.pow(leafRect.left - x, 2) + 
                                Math.pow(leafRect.top - y, 2)
                            );
                            return distance < effectiveSize;
                        });
                        
                        if (!occupied) {
                            // Add some randomness to avoid perfect grid
                            return {
                                x: x + Math.random() * margin * 2 - margin,
                                y: y + Math.random() * margin * 2 - margin
                            };
                        }
                    }
                }
                
                // If no perfect spot found, find the best available space
                let attempts = 0;
                while (attempts < 50) {
                    const x = Math.random() * (window.innerWidth - leafSize);
                    const y = Math.random() * 100; // Top 100px
                    
                    const tooClose = this.settledLeaves.some(settledLeaf => {
                        const leafRect = settledLeaf.getBoundingClientRect();
                        const distance = Math.sqrt(
                            Math.pow(leafRect.left - x, 2) + 
                            Math.pow(leafRect.top - y, 2)
                        );
                        return distance < effectiveSize * 0.8; // Allow closer packing
                    });
                    
                    if (!tooClose) {
                        return { x, y };
                    }
                    attempts++;
                }
                
                // Fallback: place randomly in top area
                return {
                    x: Math.random() * (window.innerWidth - leafSize),
                    y: Math.random() * Math.min(200, this.settledLeaves.length * 2)
                };
            }
            
            startLeafGeneration() {
                this.leafInterval = setInterval(() => {
                    this.createLeaf();
                }, this.speeds[this.speedIndex].interval);
            }
            
            stopLeafGeneration() {
                if (this.leafInterval) {
                    clearInterval(this.leafInterval);
                    this.leafInterval = null;
                }
            }
            
            updateCounter() {
                this.counter.textContent = `Leaves: ${this.leafCount} 🍃`;
            }
            
            toggle() {
                this.isRunning = !this.isRunning;
                if (this.isRunning) {
                    this.startLeafGeneration();
                } else {
                    this.stopLeafGeneration();
                }
            }
            
            clear() {
                // Remove all leaves
                [...this.leaves, ...this.settledLeaves].forEach(leaf => {
                    leaf.remove();
                });
                this.leaves = [];
                this.settledLeaves = [];
                this.leafCount = 0;
                this.updateCounter();
            }
            
            adjustSpeed() {
                this.speedIndex = (this.speedIndex + 1) % this.speeds.length;
                const speedBtn = document.querySelector('.control-btn:nth-child(3)');
                speedBtn.textContent = `Speed: ${this.speeds[this.speedIndex].name}`;
                
                if (this.isRunning) {
                    this.stopLeafGeneration();
                    this.startLeafGeneration();
                }
            }
        }
        
        // Initialize the leaf system
        const leafSystem = new LeafSystem();
        
        // Control functions
        function toggleLeafFlow() {
            leafSystem.toggle();
        }
        
        function clearLeaves() {
            leafSystem.clear();
        }
        
        function adjustSpeed() {
            leafSystem.adjustSpeed();
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            // Reposition settled leaves to fit new window size
            leafSystem.settledLeaves.forEach(leaf => {
                const rect = leaf.getBoundingClientRect();
                if (rect.left > window.innerWidth - 20) {
                    leaf.style.left = (window.innerWidth - 25) + 'px';
                }
            });
        });
    </script>
</body>
</html>